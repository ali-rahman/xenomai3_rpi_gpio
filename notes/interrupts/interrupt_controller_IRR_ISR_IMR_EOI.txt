http://www.wikiwand.com/en/Programmable_interrupt_controller


In computing, a programmable interrupt controller (PIC) is a device that is used to combine several sources of
interrupt onto one or more CPU lines, while allowing priority levels to be assigned to its interrupt outputs. When the
device has multiple interrupt outputs to assert, it asserts them in the order of their relative priority.

  => if only one cpu  :  multiplexing irq's on single line to cpu!!  (ordered by priority!)
  

PICs typically have a common set of registers: 

   Interrupt Request Register (IRR), 
   
     The IRR specifies which interrupts are pending acknowledgement, and is typically a symbolic register which 
     can not be directly accessed.
   
   In-Service Register (ISR), 
     
     The ISR register specifies which interrupts have been acknowledged, but are still waiting for an End Of Interrupt (EOI).
   
   Interrupt Mask Register (IMR).   
   
     The IMR specifies which interrupts are to be ignored and not acknowledged. A simple register schema such as this
     allows up to two distinct interrupt requests to be outstanding at one time, one waiting for acknowledgement, and
     one waiting for EOI.
  
  
   EOI short:
     Upon receiving and EOI, the APIC clears the highest priority bit in the ISR and dispatches the next highest priority
     interrupt to the processor.
  
  
   higher prio IRQ interrupts a lower's IRQ interupt handler :  (source of below note: see below)
   
     If the local APIC receives an interrupt with a priority higher than
     that of the interrupt currently in serviced, and interrupts are
     enabled in the processor core, the local APIC dispatches the higher
     priority interrupt to the processor immediately (without waiting for
     a write to the EOI register). The currently executing interrupt
     handler is then interrupted so the higher-priority interrupt can be
     handled. When the handling of the higher-priority interrupt has been
     completed, the servicing of the interrupted interrupt is resumed.
     
     
     
  
http://www.wikiwand.com/en/End_of_interrupt
                                          ,-> by CPU!!
An End Of Interrupt (EOI) is a signal sent to a Programmable Interrupt Controller (PIC) to indicate the completion of
interrupt processing for a given interrupt. An EOI is used to cause a PIC to clear the corresponding bit in the
In-Service Register (ISR), and thus allow more interrupt requests of equal or lower priority to be generated by the PIC.



 Intel APIC documentation ( a specific type of PIC !!)  => https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf
 
    at section 8.8.4 off the Intel APIC documentation /IA-32 Intel Architecture Software Developer's Manual, Volume 3A:
    System Programming Guide, Part 1 <http://developer.intel.com/design/processor/manuals/253668.pdf>/ I read a very
    clear piece of explaining text :


       The local APIC queues the fixed interrupts that it accepts in one of
       two interrupt pending registers: the interrupt request register
       (IRR) or in-service register (ISR). These two 256-bit read-only
       registers are shown in Figure 8-20. The 256 bits in these registers
       represent the 256 possible vectors; vectors 0 through 15 are
       reserved by the APIC (see also: Section 8.5.2, "Valid Interrupt
       Vectors").

       The IRR contains the active interrupt requests that have been
       accepted, but not yet dispatched to the processor for servicing.
       When the local APIC accepts an interrupt, it sets the bit in the IRR
       that corresponds the vector of the accepted interrupt. When the
       processor core is ready to handle the next interrupt, the local APIC
       clears the highest priority IRR bit that is set and sets the
       corresponding ISR bit. The vector for the highest priority bit set
       in the ISR is then dispatched to the processor core for servicing.

       While the processor is servicing the highest priority interrupt, the
       local APIC can send additional fixed interrupts by setting bits in
       the IRR. When the interrupt service routine issues a write to the
       EOI register (see Section 8.8.5, "Signaling Interrupt Servicing
       Completion"), the local APIC responds by clearing the highest
       priority ISR bit that is set. It then repeats the process of
       clearing the highest priority bit in the IRR and setting the
       corresponding bit in the ISR. The processor core then begins
       executing the service routing for the highest priority bit set in
       the ISR.

       If more than one interrupt is generated with the same vector number,
       the local APIC can set the bit for the vector both in the IRR and
       the ISR. This means that for the Pentium 4 and Intel Xeon
       processors, the IRR and ISR can queue two interrupts for each
       interrupt vector: one in the IRR and one in the ISR. Any additional
       interrupts issued for the same interrupt vector are collapsed into
       the single bit in the IRR.

       For the P6 family and Pentium processors, the IRR and ISR registers
       can queue no more than two interrupts per priority level, and will
       reject other interrupts that are received within the same priority
       level.

       If the local APIC receives an interrupt with a priority higher than
       that of the interrupt currently in serviced, and interrupts are
       enabled in the processor core, the local APIC dispatches the higher
       priority interrupt to the processor immediately (without waiting for
       a write to the EOI register). The currently executing interrupt
       handler is then interrupted so the higher-priority interrupt can be
       handled. When the handling of the higher-priority interrupt has been
       completed, the servicing of the interrupted interrupt is resumed.


http://manualmachine.com/intel/architecture-ia-32/780694-user-manual/page:86/#211

8.8.5 Signaling Interrupt Servicing Completion

    For all interrupts  the interrupt handler must include a write to theend-of-interrupt(EOI) register. 
    This write must occur at the end of the handler routine, sometime before the IRET instruction. 

    This action indicates that the servicing of the current interrupt is complete and the local APIC can issue the next
    interrupt from the ISR.


    Upon receiving and EOI, the APIC clears the highest priority bit in the ISR and dispatches the next highest priority
    interrupt to the processor. If the terminated interrupt was a level-triggered interrupt, the local APIC also sends
    an end-of-interrupt message to all I/O APICs.
  
  
  
https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller

 While cli and sti can be used to disable and enable all hardware interrupts, it's sometimes desirable to selectively
disable interrupts from certain devices. For this purpose, PICs have an internal 8-bit register called the Interrupt
Mask Register (IMR). The bits in this register determine which IRQs are passed on to the CPU. If an IRQ is raised but
the corresponding bit in the IMR is set, it is ignored and nothing is sent to the CPU.

 => interrupt is probably buffered, when  the entry for the IRQ is unset in the IMR it still is put into the IRR!!
                 `> for sure!!
                   see:
                   
                    https://stackoverflow.com/questions/10817654/can-a-masked-interrupt-be-received-after-the-mask-canceled
                      question: 
                      

                        If an interrupt is masked by "cli" instruction, can the same interrupt (not interrupts of the same source)be received by the cpu after a "sti" instruction?
                        
                      
                      answer:
                        In almost all reasonable interrupt applications, masking out an interrupt does just that; unmasking it will cause the CPU to accept any pending interrupt requests.
                        
                        

IRQ sharing
------------

 src: keyboard_irq_sharing_xenomai_linux_eoi__discussion_on_xenomai_mailinglist.txt


For correct handling of shared IRQs, _all_ associate IRQ handlers
                                 ^^^^^^
    must have been executed before the EOI can be sent. 
    
    The reason is this:

        For level-triggered IRQs,
        
           all hardware devices that may have raised the IRQ line must be checked and told to lower it again before
           sending EOI. Otherwise the IRQ will immediately be triggered again and you end up in an endless loop,
           bricking your box.

        For edge-triggered IRQs, 
        
           there problem is different. Here the shared IRQ handling algorithm is to consult all handlers in a loop until
           they all reported "not for me" in a row. If you fail to do this, you risk loosing IRQs. Consider IRQ source
           A and B. Now an IRQ is raised by B. First, the handler for A will be called. It return "not for me". Now it
           happens that A also raised the IRQ right at this time. If you now simply log the IRQ for later handling by B
           and send the EOI, you take away the CHANCE for handle A to react on the IRQ. At best you create latency, at
           worst A will never send an IRQ again... |      -----------------------------
                                                   |         |               
                                    take away CHANCE         | 
                                       but not LOST          |  
                                                              `-> IRQ is shared, CPU can check the IRQ is triggered for device A 
                                                                  using device specific code. If handler A is not called
                                                                  the interrupt stays triggered in the device specific status
                                                                  line. So if handle not called when IRQ happened, then
                                                                    - can be called then next time IRQ happens.
                                                                      This IRQ maybe even caused by another device,
                                                                      but device A is still triggered in its device own status register
                                                                      So can be handled then:  => handler IRQ later =>  latency 
                                                                    - IRQ never happens again                       => IRQ missed
                                                                  
                                                                  
                                                                  source: http://www.wikiwand.com/en/Interrupt#Level-triggered
                                                                     the CPU may recheck the interrupt line status to determine whether any other devices also needs service 
                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
                                                                                          `-> just loop over all handlers for the IRQ
                                                                                              each handler knows how to check whether its device is triggered
                                                                                              with device specific code!
                                                                                          
        => also see: http://www.wikiwand.com/en/Interrupt#Types_of_interrupts !!   





good documentation

  http://retired.beyondlogic.org/interrupts/interupt.htm
  
  => http://retired.beyondlogic.org/interrupts/interupt.htm#6
       very clearly documents interrupt controller
       
       